import { XMLParser } from "fast-xml-parser";
import path from "path";
import { z, type ZodType } from "zod";
import { createTypeAlias, printNode, zodToTs } from "zod-to-ts";
import { mkdir, writeFile } from "fs/promises";
import serialize from "serialize-javascript";
import { Biome } from "@biomejs/js-api/nodejs";
import { load as loadHTML } from "cheerio";

const WORKSPACE_ROOT = path.resolve(__dirname, "../../");
const PROJECT_ROOT = path.resolve(WORKSPACE_ROOT, "../../");
const BASE_PATH = "./src/codelists";

type LiteralString = "" | (string & Record<never, never>);
type Promisable<T> = T | Promise<T>;
export type Arrayable<T> = T | T[];

export const arrayable = <T>(input: Arrayable<T>): T[] => {
	return !Array.isArray(input) ? [input] : input;
};

export type Import = {
	asType?: boolean;
	path: string;
	name?: string;
	variables?: Arrayable<{
		asType?: boolean;
		name: string;
		as?: string;
	}>;
};

export type CreateParserResult<
	Definition extends ZodType<object> = ZodType<object>,
> = {
	path: string;
	source: string;
	identifier: LiteralString;
	secondaryIdentifier: LiteralString;
	destination: string;
	definition: Definition;
	imports?: Import[];
	constants?: Record<
		string,
		{
			value: unknown;
			type?: ZodType;
			asConst?: boolean;
			/**
			 * @default "before-satisfies"
			 */
			asPosition?: "before-satisfies" | "after-satisfies";
			satisfies?: string | ZodType;
			/**
			 * @default "const"
			 */
			mode?: "let" | "const";
			export?: boolean;
		}
	>;
	typeDefs?: Record<
		string,
		{
			export?: boolean;
			type: ZodType;
		}
	>;
	data: z.input<Definition>[];
	enum: {
		key?: keyof z.infer<Definition>;
		value: keyof z.infer<Definition>;
	};
};

export type ParserContext = {
	toScreamingSnakeCase: typeof toScreamingSnakeCase;
	getTextNode: typeof getTextNode;
	parseXML: typeof parseXML;
	parseUneceList: typeof parseUneceList;
	serializePath: typeof deserializePath;
	deserializePath: typeof serializePath;
};

const parseUneceList = async (url: string) => {
	const response = await fetch(url);
	const html = await response.text();

	const $ = loadHTML(html);
	const preText = $("pre").text();
	const lines = preText.split(/\r?\n/);

	const data: {
		key: string;
		name: string;
		value: string;
		description: string;
	}[] = [];
	let current = null;

	for (const line of lines) {
		const match = line.match(/^\s*([A-Z0-9]{1,3})\s{2,}(.+)/);
		if (match) {
			if (current) {
				data.push(current);
			}
			const name = match[2]?.trim();

			current = {
				key: toScreamingSnakeCase(name),
				name,
				value: match[1]?.trim(),
				description: "",
			};
		} else if (current) {
			const descLine = line.trim();
			if (descLine) {
				current.description += (current.description ? " " : "") + descLine;
			}
		}
	}

	if (current) {
		data.push(current);
	}

	return data;
};

const parseXML = <R = any>(xml: string | Buffer) => {
	const parser = new XMLParser({
		ignoreAttributes: false,
		parseTagValue: false,
		attributeNamePrefix: "@",
		textNodeName: "#",
	});

	return parser.parse(xml) as R;
};

const toScreamingSnakeCase = (input: string) => {
	return input
		.normalize("NFD")
		.replace(/([a-z0-9])([A-Z])/g, "$1_$2")
		.replace(/[\s\-]+/g, "_")
		.replace(/[^a-zA-Z0-9_]/g, "")
		.toUpperCase();
};

const getTextNode = (node: string | { "#": string }) => {
	if (typeof node === "object" && "#" in node) {
		return node["#"];
	}

	return node;
};

const deserializePath = (path: string) => {
	if (path === "") {
		path = "./";
	}
	path = path.replace(/\\/g, "/");
	return path;
};
const serializePath = (path: string) => path.replace(/\//g, "\\");

const uniqueKey = <T, K extends keyof T>(entries: T[], key: K) => {
	const set = new Set<T[K]>();
	return entries.filter((entry) => {
		if (set.has(entry[key])) {
			throw new Error(
				`Duplicate value "${String(entry[key])}" found for property "${String(key)}"`,
			);
		}
		set.add(entry[key]);
		return true;
	});
};

export const createParser = <D extends ZodType<object>>(
	parser: (ctx: ParserContext) => Promisable<
		CreateParserResult<D> & {
			definition: D;
		}
	>,
) => {
	return {
		generate: async () => {
			const data = await parser({
				toScreamingSnakeCase,
				getTextNode,
				parseXML,
				parseUneceList,
				serializePath,
				deserializePath,
			});
			const dest = path.resolve(WORKSPACE_ROOT, BASE_PATH, data.destination);
			const destDir = path.dirname(dest);

			const comment = `/**
* Automatically generated by {@link Script} on ${new Date().toUTCString()}
*
* @see {@link ${new URL(deserializePath(data.source.replace(`${WORKSPACE_ROOT}\\`, "")), "https://github.com/jslno/node-zugferd/blob/main/packages/node-zugferd/")}|Source}
*/`;

			const baseImports: Import[] = [
				{
					asType: true,
					name: "Script",
					path: deserializePath(path.relative(destDir, data.path)),
				},
			];

			const createEnum = data.enum.key
				? `export const ${data.secondaryIdentifier} = createEnum(${data.identifier}, {
  keyProp: "${String(data.enum.key)}",
  valueProp: "${String(data.enum.value)}",
});`
				: "";

			if (!!createEnum) {
				baseImports.push({
					path: deserializePath(
						path.relative(destDir, path.resolve(WORKSPACE_ROOT, BASE_PATH)),
					),
					variables: {
						name: "createEnum",
					},
				});
			}

			const imports = uniqueKey([...baseImports], "path")
				.map((entry) => {
					if (
						!entry.name &&
						(!entry.variables ||
							(Array.isArray(entry.variables) && entry.variables.length === 0))
					) {
						console.log(entry);
						throw new Error("Invalid import", {
							cause: entry,
						});
					}

					const variables = Array.isArray(entry.variables)
						? entry.variables
						: typeof entry.variables === "object"
							? [entry.variables]
							: [];
					const isAsType =
						(entry.asType &&
							!variables.some((variable) => variable.asType === false)) ||
						variables.every((variable) => !!variable.asType);
					const isAsVariable =
						entry.name &&
						entry.asType &&
						variables.some((variable) => !variable.asType);
					if (isAsVariable) {
						variables.push({
							name: "default",
							as: entry.name,
							asType: true,
						});
					}

					let str = `import ${isAsType ? "type " : ""}`;
					if (entry.name && !isAsVariable) {
						str += entry.name;
					}
					if (entry.name && !isAsVariable && variables.length > 0) {
						str += ", ";
					}
					if (variables.length > 0) {
						str += "{ ";
						str += variables
							.map((variable) => {
								let res = "";

								if (!isAsType && variable.asType) {
									res += "type ";
								}

								res += variable.name;

								if (variable.as) {
									res += ` as ${variable.as}`;
								}

								return res;
							})
							.join(", ");
						str += " }";
					}
					str += ` from "${entry.path}";`;

					return str;
				})
				.join("\n");

			const typeDefs = Object.entries(data.typeDefs ?? {})
				.map(([identifier, def]) => {
					const { node } = zodToTs(def.type, identifier);
					const typeAlias = createTypeAlias(
						node,
						identifier,
						def.type.description,
					);

					return `${def.export ? "export " : ""}${printNode(typeAlias)}`;
				})
				.join("\n");

			const constants = (
				await Promise.all(
					Object.entries(data.constants ?? {}).map(
						async ([identifier, constant]) => {
							const declaration = constant.mode ?? "const";

							let str = `${constant.export ? "export " : ""}${declaration} ${identifier}`;
							if (constant.type) {
								const { node } = zodToTs(constant.type);
								str += `: ${printNode(node)}`;
							}

							str += ` = ${serialize(constant.value)}`;

							const handleAsConst = () => {
								if (!constant.asConst) {
									return;
								}

								str += " as const";
							};
							const handleSatisfies = () => {
								if (!constant.satisfies) {
									return;
								}

								let type: string;

								if (typeof constant.satisfies === "string") {
									type = constant.satisfies;
								} else {
									const { node } = zodToTs(constant.satisfies);
									type = printNode(node);
								}

								str += ` satisfies ${type}`;
							};

							const typeOpQueue = [handleAsConst, handleSatisfies];
							if (constant.asPosition === "after-satisfies") {
								typeOpQueue.reverse();
							}
							for (const operation of typeOpQueue) {
								operation();
							}

							str += ";";

							return str;
						},
					),
				)
			).join("\n");

			const definitionType = createTypeAlias(
				zodToTs(data.definition, `${data.secondaryIdentifier}Definition`).node,
				`${data.secondaryIdentifier}Definition`,
			);

			const content = `${comment}

${imports.length > 0 ? imports + "\n" : ""}
export ${printNode(definitionType)}
export type ${data.secondaryIdentifier}Code = (typeof ${data.identifier})[number]["${String(data.enum.value)}"];
${typeDefs.length > 0 ? typeDefs + "\n" : ""}
${constants.length > 0 ? constants + "\n" : ""}
${comment}
export const ${data.identifier} = ${serialize(data.definition.array().parse(data.data))} as const satisfies ${data.secondaryIdentifier}Definition[];

export const ${data.secondaryIdentifier.charAt(0).toLowerCase() + data.secondaryIdentifier.slice(1)}Code = ${data.identifier}.map(({ ${String(data.enum.value)} }) => ${String(data.enum.value)} );

${createEnum}
`;

			const biome = new Biome();
			const { projectKey } = biome.openProject(PROJECT_ROOT);

			await mkdir(destDir, { recursive: true });

			const { content: formattedContent } = biome.formatContent(
				projectKey,
				content,
				{
					filePath: dest,
				},
			);

			await writeFile(dest, formattedContent);
		},
	};
};
