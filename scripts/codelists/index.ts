import { writeFile } from "node:fs/promises";
import path from "node:path";
import { Biome } from "@biomejs/js-api/nodejs";
import serialize from "serialize-javascript";

const codelists = [
	import("./allowance"),
	import("./characteristic"),
	import("./charge"),
	import("./country"),
	import("./currency"),
	import("./date"),
	import("./eas"),
	import("./fiscal-id"),
	import("./icd"),
	import("./incoterms"),
	import("./item"),
	import("./language"),
	import("./line-reason"),
	import("./line-status"),
	import("./mime"),
	import("./payment"),
	import("./text"),
	import("./time"),
	import("./transport"),
	import("./unit"),
	import("./untdid-1001"),
	import("./untdid-1153"),
	import("./untdid-3035"),
	import("./untdid-3139"),
	import("./untdid-5305"),
	import("./vat-cat"),
	import("./vat-id"),
	import("./vatex"),
];

const PROJECT_ROOT = path.resolve(__dirname, "../../");

async function main() {
	const biome = new Biome();
	const { projectKey } = biome.openProject(PROJECT_ROOT);

	for await (const { default: codelist } of codelists) {
		const data = await codelist.exec();

		const dest = path.resolve(
			PROJECT_ROOT,
			`./packages/codelists/${codelist.id}/src/index.ts`,
		);

		const comment = `/**
 * This file is auto-generated. Do not edit this file directly.
 * To update the codelist, edit the generator script at scripts/codelists/${codelist.id}/index.ts
 * and run \`pnpm run script:codelists\`.
 */`;

		const codelistName = toCamelCase(codelist.id);

		const typeDefName = `${toPascalCase(codelist.id)}Definition`;
		const typeDef = `export type ${typeDefName} = {
${Object.entries(codelist.definition)
	.map(([key, def]) => {
		const optional = def.required === false;
		return `${key}${optional ? "?" : ""}: ${def.type}${optional ? " | undefined" : ""};`;
	})
	.join("\n")}
};`;

		const enumName = `${toPascalCase(codelist.id)}`;
		const enumDef = `
export type ${enumName} = {
	[K in (typeof ${codelistName})[number] as K["${codelist.accessorKey}"]]: K["${codelist.accessorValue}"];
};

export const ${enumName} = Object.fromEntries(
	${codelistName}.map((item) => [item.${codelist.accessorKey}, item.${codelist.accessorValue}]),
) as ${enumName};
`;

		const rawContent = `
${comment}

${typeDef}

export const ${codelistName} = ${serialize(
			data.map((entry) => {
				return Object.fromEntries(
					Object.keys(codelist.definition).map((key) => {
						let value = entry[key];
						if (
							(value === undefined || value === null) &&
							codelist.definition[key].required !== false
						) {
							throw new Error(
								`Missing required key "${key}" in codelist "${codelist.id}": ${JSON.stringify(
									entry,
								)}`,
							);
						}

						return [key, value];
					}),
				);
			}),
			{
				unsafe: true,
			},
		)} as const satisfies ${typeDefName}[];

${enumDef}
		`;
		const { content } = await biome.formatContent(projectKey, rawContent, {
			filePath: dest,
		});

		await writeFile(dest, content, "utf-8");

		console.info(`Generated codelist: ${codelist.id}`);
	}

	console.log("Codelists generated successfully.");

	return Promise.resolve();
}

void main();

function capitalizeFirstChar(input: string) {
	return input.charAt(0).toUpperCase() + input.slice(1);
}

function toCamelCase(input: string) {
	return input
		.trim()
		.normalize("NFD")
		.toLowerCase()
		.replace(/[\s_\-\/]+(.)?/g, (_, char) => (char ? char.toUpperCase() : ""));
}

function toPascalCase(input: string) {
	const camel = toCamelCase(input);
	return capitalizeFirstChar(camel);
}
